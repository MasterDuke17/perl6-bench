# the code is ported from: http://wiki.luajit.org/Allocation-Sinking-Optimization

# this benchmark is useful for Allocation Sinking Optimization or Escape Analysis Optimization

# Point Class Benchmarks

# Here's the runtime for the point class in seconds (YMMV). Lower is better:
# Time  Point object    VM/Compiler
# 140.0 Lua table       Lua 5.1.5
# 26.9  Lua table       LuaJIT 2.0 git HEAD -O-sink
# 10.9  FFI struct      LuaJIT 2.0 git HEAD -O-sink
# 0.2   Lua table       LuaJIT 2.0 git HEAD -O+sink
# 0.2   FFI struct      LuaJIT 2.0 git HEAD -O+sink
# 0.2   C++ class       GCC 4.4.3 -O2 (or -O3)
# 1.2   Java class      JVM/Hotspot 1.7.0_05
# 150    NQP class       NQP/MoarVM


class Point {
    has num $!x;
    has num $!y;
    method new(num $x, num $y) {
        my $self := nqp::create(self);
        nqp::bindattr_n($self, Point, '$!x', $x);
        nqp::bindattr_n($self, Point, '$!y', $y);

        $self;
    }

    method x() { $!x }
    method y() { $!y }

    # multi method version makes it 2x slower
    # but perl6 version with 'multi method add ' is about the same speed.
    proto method add($b) { * }
    multi method add(num $b) {
    }

    multi method add (Point $b) {
        Point.new($!x + $b.x, $!y + $b.y);
    }
}

my int $i := 0;
my $a := Point.new(1.5e0, 2.5e0);
my $b := Point.new(3.25e0, 4.75e0);
while $i < 100000000 {
    $a := $a.add($b).add($b);
    $i := $i + 1;
}
print($a.x, $a.y);
