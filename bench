#!/usr/bin/env perl6

# ABSTRACT: Master console/"porcelain" for Perl language family benchmarking tools

use v6;

use lib <lib>;

use Bench::Handling;
use Bench::Globals;


use JSON::Tiny;
use Shell::Command;

go_to_bench_dir();
init_bench_handling();

# MAIN COMMANDS

#= Show benchmark configuration
multi MAIN ('config') {
    my $perl6 = $*PERL.compiler;
    print qq:to/CONFIG/;
        Benchmark root:    $PROGRAM_DIR
        Perl 6 program:    $*EXECUTABLE_NAME
        Perl 6 version:    $perl6.name() $perl6.version() (built $perl6.build-date())
        Known components:  $COMPONENTS.keys.sort.join(', ')
        CONFIG
}

#= Prepare for mass benchmarking
multi MAIN ('setup') {
    say 'Creating directories ...';
    mkdir $COMPONENTS_DIR unless $COMPONENTS_DIR.path.d;

    say 'Cloning component repos ...';
    for $COMPONENTS.values -> $component {
        my $name = $component<name>;
        say "==> $name";

        chdir $COMPONENTS_DIR;
        mkdir $name unless $name.path.d;
        chdir $name;

        my $repo = $component<repo_url>;
        my $bare = "$name.git";
        say "----> Already cloned." if $bare.path.d && $name.path.d;
        run < git fetch >           if $bare.path.d && $name.path.d;
        run < git clone --mirror >, $repo, $bare unless $bare.path.d;
        run < git clone -l       >, $bare, $name unless $name.path.d;
    }

    say 'Setup complete.';
}

#= Fetch latest commits in each cloned component
multi MAIN ('fetch', *@components) {
    needs-setup('fetch');

    for-components @components, -> $comp, $name {
        my $comp_dir = "$COMPONENTS_DIR/$name";
        my $bare     = "$name.git";

        unless "$comp_dir/$bare".path.d {
            say "No bare repository exists for component $name; can't fetch updates.";
            next;
        }

        # Work around Rakudo bug #115390 by splitting into multiple loops
        # (And this time, it doesn't even seem to completely go away!)

        # Fetch commits in bare mirror first, then requested checkouts
        say '~~~> FETCHING';
        for $bare, $comp<checkouts>.list -> $dir {
            my $path = "$comp_dir/$dir";
            next unless $path.path.d;

            say "----> $dir";
            chdir $path;
            run < git fetch -t >;
            run < git fetch -u >;
        };

        # Find all tags known in this component
        %*ENV<GIT_DIR> = "$comp_dir/$bare";
        my $tag-list = open 'git tag', :p;
        my @all-tags = $tag-list.lines;
        $tag-list.close;
        %*ENV<GIT_DIR>:delete;

        # Pull into non-tag checkouts
        say '~~~> PULLING';
        for $comp<checkouts>.list -> $dir {
            my $path = "$comp_dir/$dir";
            next unless "$path/.git".path.d;
            next if $dir eq any(@all-tags);

            say "----> $dir";
            chdir $path;
            run < git pull >;
        }
    }
}

#= Alias for 'extract'
multi MAIN ('extract-releases', *@components) { MAIN('extract', |@components) }

#= Extract historical releases from cloned components
multi MAIN ('extract', *@components) {
    needs-setup('extract releases');

    for-components @components, -> $comp, $name {
        chdir "$COMPONENTS_DIR/$name";

        my $bare = "$name.git";
        unless $bare.path.d {
            say "No bare repository exists for component $name; can't extract releases.";
            next;
        }

        # Find all tags known in this component
        %*ENV<GIT_DIR> = $bare;
        my $tag-list = open 'git tag', :p;
        my @all-tags = $tag-list.lines;
        $tag-list.close;

        my @revs;
        if $comp<checkouts> {
            # User specified list of revs to extract
            for $comp<checkouts>.list {
                when any(@all-tags) { push @revs, $_ }
                when so run(< git rev-parse -q --verify --no-revs >, $_) { push @revs, $_ }
                default  { $*ERR.say: "No such rev '$_'" }
            }
        }
        else {
            # Check out filtered tag list by default
            my $tag_regex = $comp<info><release_tags>;
            next unless $tag_regex;

            @revs = grep / <{ $tag_regex }> /, @all-tags;
        }

        %*ENV<GIT_DIR>:delete;

        # Work around Rakudo bug #115390 by splitting into multiple loops
        for @revs -> $rev {
            if $rev.path.d {
                say "$rev already cloned.";
                next;
            }
            run < git clone -l >, $bare, $rev;
        }
        for @revs -> $rev {
            unless $rev.path.d {
                $*ERR.say: "Unable to extract release '$rev'.";
                next;
            }
            chdir $rev; LEAVE chdir '..';
            run < git checkout -q >, $rev;   # > -- Dang syntax highlighting
        }
        for @revs -> $rev {
            next unless $rev.path.d;
            next if $rev eq any(@all-tags);

            chdir $rev; LEAVE chdir '..';
            run < git pull >;
        }
    }
}

#= List known components with clone status
multi MAIN ('list-components') {
    my @names = $COMPONENTS.keys.sort;
    my $max-length = max('COMPONENT'.chars, @names>>.chars);
    my $format = "%-{$max-length}s    %s\n";
    printf $format, < COMPONENT STATUS >;
    printf $format, < --------- ------ >;

    my $missing;
    for @names -> $name {
        my $bare-dir = "$COMPONENTS_DIR/$name/$name.git";
        my $desc     = $bare-dir.IO.d ?? 'cloned' !! do { $missing++; '[NOT FOUND]' };
        printf $format, $name, $desc;
    }

    say "\nPlease run `$*PROGRAM_NAME setup` to clone missing components." if $missing;
}

#= List checked out component trees with matching git revision
multi MAIN ('list-checkouts', *@components) {
    needs-setup('list');

    my @lengths = for-checkouts @components, -> $, $name, $checkout { "$name/$checkout".chars }, :quiet;
    my $max-length = max('CHECKOUT'.chars, @lengths);
    my $format = "%-{$max-length}s    %s\n";
    printf $format, < CHECKOUT REVISION >;
    printf $format, < -------- -------- >;

    for-checkouts @components, -> $comp, $name, $checkout {
        my $subdir   = "$name/$checkout";
        my $comp-dir = "$COMPONENTS_DIR/$subdir";
        my $desc     = '[NOT FOUND]';
        if $comp-dir.IO.d {
            given "$comp-dir/.git" {
                when .IO.d { %*ENV<GIT_DIR> = $_;
                             $desc = qx/git describe --always/.chomp }
                default    { $desc = '[NOT A GIT CHECKOUT]' }
            }
        }
        printf $format, $subdir, $desc;
    }, :quiet;
}

#= Build checked out component trees
multi MAIN ('build', *@components) {
    needs-setup('build components');

    for-checkouts @components, -> $comp, $name, $checkout {
        chdir "$COMPONENTS_DIR/$name/$checkout";

        my $build_steps = $comp<info><build_steps>;
        for $build_steps.list -> $step {
            $step ~~ Positional ?? run(|$step) !! shell($step);
        }
    }
}

#= Run timing benchmarks on (variants of) built components
multi MAIN ('time', *@components, :$variants?, :$tests?, :$tests-tagged?,
                                  :$runs?, :$enough-time?, Bool :$verbose?) {
    needs-setup('benchmark Perls');

    my @options = as-options(:$tests, :$tests-tagged, :$runs, :$enough-time, :$verbose);

    for-checkouts @components, -> $comp, $name, $checkout {
        chdir "$COMPONENTS_DIR/$name/$checkout";

        my $timings_dir = "$TIMINGS_DIR/$name";
        mkpath $timings_dir;

        my @variants = $variants ?? $variants.split(',') !! $name;
        run "$PROGRAM_DIR/timeall", "--outfile=$timings_dir/$checkout.json",
                                    @options, @variants;
    }
}

#= Compare benchmark timings
multi MAIN ('compare', *@timings, :$format?, :$style?, :$outfile?,
            :$ignore-startup = True, :$ignore-compile = True) {
    needs-timings('compare');

    my @options = as-options(:compare, :$ignore-startup, :$ignore-compile, :$format, :$style, :$outfile);

    my @timings-files;
    for explode-timings(@timings, :!chdir).kv -> $component, @files {
        @timings-files.push: @files.map: "$TIMINGS_DIR/$component/" ~ *;
    }

    run "$PROGRAM_DIR/analyze", @options, @timings-files;
}

#= Clean up build trees in $COMPONENTS_DIR, keeping bare clones by default
multi MAIN ('clean', *@components) {
    unless $COMPONENTS_DIR.path.d {
        say "No 'components' tree exists, so there is nothing to clean.";
        exit;
    }

    for-checkouts @components, -> $comp, $name, $checkout {
        rm_rf "$COMPONENTS_DIR/$name/$checkout";
    }
}

#= Remove *everything* not part of the core benchmark tree
multi MAIN ('realclean', Bool :$force) {
    unless $force {
        print q:to/NEED_FORCE/;  # : -- Dang syntax highlighting
            Are you sure?

            This command will wipe your benchmarking tree clean, destroying any builds,
            cloned components, and benchmark results in the process.  You will need
            to use the --force option if you really want to do this.
            NEED_FORCE
        exit;
    }

    # OK, you asked for it!
    say "OK, performing realclean.";
    rmtree $_ for $COMPONENTS_DIR, $TIMINGS_DIR;
    run < git clean -dxf >;
}

#= Perform benchmark timings (low-level command)
multi MAIN ('timeall', *@options) {
    run('./timeall', |@options);
}

#= Analyze results from benchmark timings (low-level command)
multi MAIN ('analyze', *@options_and_files) {
    run('./analyze', |@options_and_files);
}
